#ifndef _GD_CUBETEXTURE_H
#define _GD_CUBETEXTURE_H


#include <gd/BaseTexture.h>


namespace pix {
	class Surface;
	class SurfaceFormat;}


namespace gd
{


class Material;
class LockMode;
class GraphicsDevice;


/** 
 * Interface to cube texture used in surface shading.
 * @author Toni Aittoniemi, Jani Kajala (jani.kajala@helsinki.fi)
 */
class CubeTexture :
	public BaseTexture
{
public:
	/** Increments reference count by one. */
	virtual void	addReference() = 0;

	/** Decrements reference count by one and releases the object if no more references left. */
	virtual void	release() = 0;

	/**
	 * Creates an empty texture of specified size.
	 * @param edgelength Preferred width and height of the texture.
	 * @param format Preferred pixel format of the texture surface.
	 * @return Error code or 0 if ok.
	 */
	virtual int		create( int edgelength, const pix::SurfaceFormat& format ) = 0;

	/**
	 * Creates a texture from the temporary surface.
	 * <em>Note</em> that surface data is transferred by <em>swapping</em>,
	 * so original surface data passed in to the function is destroyed.
	 * Surface data must contain at least 6 * mipmapcount surfaces, or
	 * if mipmapcount is 0, 6 surfaces, and mipmaplevels are generated by
	 * the implementation.
	 * @param surface Source surface array which is destroyed by the function.
	 * @param mipmaplevels mipmap levels in array, pass 0 to generate mipmaps.
	 * @return Error code or 0 if ok.
	 */
	virtual int		create( pix::Surface* surfaces, int mipmaplevels ) = 0;

	/** Deinitializes the texture explicitly. */
	virtual void	destroy() = 0;

	/** Uploads object to the rendering device. */
	virtual void	load( gd::GraphicsDevice* device ) = 0;

	/** Unloads object from the rendering device. */
	virtual void	unload() = 0;

	/** 
	 * Gets access to surface data.
	 * Call unlock() to release the access.
	 * data() can be used after this. 
	 * @return false if lock failed.
	 */
	virtual bool	lock( const gd::LockMode& mode, int subsurface ) = 0;
	
	/** 
	 * Release access to the surface data.
	 * @see lock
	 */
	virtual void	unlock( int subsurface ) = 0;

	/** Returns pointer to surface data. Can be called only when locked. */
	virtual void*	data( int subsurface ) = 0;

	/** Returns width of the surface. */
	virtual int		width() const = 0;
	
	/** Returns height of the surface. */
	virtual int		height() const = 0;
	
	/** Returns pixel format of the surface. */
	virtual const pix::SurfaceFormat&	format() const = 0;

	/** Returns true if buffer is already locked. */
	virtual bool						locked( int subsurface ) const = 0;
	
	/** Returns pointer to surface data. Can be called only when locked. */
	virtual const void*					data( int subsurface ) const = 0;

	/** Returns distance (in bytes) to the start of next line. */
	virtual int							pitch() const = 0;

	/** Returns (approximate) number of bytes texture memory used by the texture. */
	virtual long						textureMemoryUsed() const = 0;

protected:
	CubeTexture() {}
	virtual ~CubeTexture() {}

private:
	CubeTexture( const CubeTexture& );
	CubeTexture& operator=( const CubeTexture& );
};


} // gd


#endif // _GD_CUBETEXTURE_H
